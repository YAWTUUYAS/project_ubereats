{% extends "base.html" %}
{% block title %}Panier{% endblock %}
{% block content %}
<div class="page-header">
  <h2>üõí Panier</h2>
  <p class="muted">V√©rifiez votre commande avant de valider</p>
</div>

<div class="cart-section">
  {% if panier %}
    <div class="cart-header">
      <div class="cart-title">
        <h3>üõí Votre panier</h3>
        {% if panier[0].restaurant_name %}
          <p class="restaurant-name">üìç {{ panier[0].restaurant_name }}</p>
        {% endif %}
      </div>
      <div class="cart-actions">
        <button type="button" id="clear-cart" class="btn btn-outline-danger btn-sm">
          üóëÔ∏è Vider le panier
        </button>
        <button type="button" id="update-cart" class="btn btn-outline-primary btn-sm">
          üîÑ Mettre √† jour
        </button>
      </div>
    </div>
    
    <div class="cart-items">
      {% for it in panier %}
        <div class="cart-item" data-item="{{ it.nom }}">
          <div class="item-info">
            <h4>{{ it.nom }}</h4>
            <p class="item-price-unit">{{ "%.2f"|format(it.pu) }} ‚Ç¨ l'unit√©</p>
          </div>
          
          <div class="item-quantity-controls">
            <button type="button" class="btn-quantity btn-quantity-minus" data-item="{{ it.nom }}" data-action="decrease">-</button>
            <input type="number" class="quantity-input" value="{{ it.qty }}" min="0" max="10" data-item="{{ it.nom }}" data-price="{{ it.pu }}">
            <button type="button" class="btn-quantity btn-quantity-plus" data-item="{{ it.nom }}" data-action="increase">+</button>
            <button type="button" class="btn-remove" data-item="{{ it.nom }}" title="Supprimer l'article">‚ùå</button>
          </div>
          
          <div class="item-total">
            <strong class="item-total-price">{{ "%.2f"|format(it.qty * it.pu) }} ‚Ç¨</strong>
          </div>
        </div>
      {% endfor %}
    </div>

    {% set total = [] %}
    {% for it in panier %}
      {% set _ = total.append(it.qty * it.pu) %}
    {% endfor %}
    {% set total_sum = total | sum %}
    
    <div class="cart-summary">
      <div class="total-line">
        <span>Total estim√© :</span>
        <strong class="total-price">{{ "%.2f"|format(total_sum) }} ‚Ç¨</strong>
      </div>
    </div>
  {% else %}
    <div class="empty-state">
      <h3>üõí Panier vide</h3>
      <p class="muted">Ajoutez des plats √† votre panier pour commencer votre commande</p>
      <a href="{{ url_for('client_restaurants') }}" class="btn btn-primary">Voir les restaurants</a>
    </div>
  {% endif %}
</div>

{% if panier %}
<div class="checkout-section">
  <h3>üìç Informations de livraison</h3>
  
  <div class="delivery-form-container">
    <div class="address-section">
      <div class="form-group">
        <label>üìç Adresse de livraison</label>
        <input id="address-input" name="adresse" type="text" placeholder="Tapez votre adresse ou cliquez sur la carte..." class="address-search" required>
        <div id="address-suggestions" class="address-suggestions"></div>
        <div class="address-actions">
          <button type="button" id="use-current-location" class="btn btn-outline-primary btn-sm">
            üìç Utiliser ma position actuelle
          </button>
          <button type="button" id="clear-address" class="btn btn-outline-secondary btn-sm">
            üóëÔ∏è Effacer
          </button>
        </div>
      </div>
      
      <div class="form-group">
        <label>üó∫Ô∏è Zone de livraison</label>
        <input name="zone" id="delivery-zone" placeholder="Zone d√©tect√©e automatiquement" required readonly>
        <div id="zone-info" class="zone-info"></div>
      </div>
      
    </div>
    
    <div class="map-section">
      <div id="map" class="delivery-map"></div>
      <div class="map-controls">
        <button type="button" id="center-map" class="btn btn-sm btn-outline-primary">
          üéØ Centrer sur ma position
        </button>
        <button type="button" id="toggle-zones" class="btn btn-sm btn-outline-primary">
          üó∫Ô∏è Afficher les zones
        </button>
        <button type="button" id="test-zones" class="btn btn-sm btn-outline-secondary">
          üîç Tester zones
        </button>
      </div>
    </div>
  </div>
  
  <form method="post" class="checkout-form" id="checkout-form">
    <input type="hidden" name="adresse" id="final-address">
    <input type="hidden" name="zone" id="final-zone">
    {% if panier and panier[0].id_restaurant %}
      <input type="hidden" name="id_restaurant" id="final-restaurant" value="{{ panier[0].id_restaurant }}">
    {% else %}
      <!-- fallback pour debug -->
      <p class="text-danger">‚ö†Ô∏è Impossible de d√©terminer l‚ÄôID du restaurant (panier vide ou mal form√©)</p>
    {% endif %}
    <button type="submit" class="btn btn-success btn-large" id="submit-order" disabled>
      ‚úÖ Valider la commande
    </button>
  </form>
</div>
{% endif %}
{% endblock %}

{% block scripts %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
      crossorigin=""/>

<!-- Leaflet JavaScript -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>

<script>
// Configuration des zones de livraison (√† adapter selon vos besoins)
const DELIVERY_ZONES = {
  'paris-1': { 
    name: 'Paris 1er', 
    bounds: [[48.8500, 2.3200], [48.8700, 2.3600]], // Zone √©largie
    color: '#3b82f6',
    deliveryFee: 2.50,
    estimatedTime: '25-35 min'
  },
  'paris-2': { 
    name: 'Paris 2√®me', 
    bounds: [[48.8500, 2.3300], [48.8800, 2.3700]], // Zone √©largie
    color: '#10b981',
    deliveryFee: 2.50,
    estimatedTime: '20-30 min'
  },
  'paris-3': { 
    name: 'Paris 3√®me', 
    bounds: [[48.8500, 2.3400], [48.8800, 2.3800]], // Zone √©largie
    color: '#f59e0b',
    deliveryFee: 3.00,
    estimatedTime: '25-35 min'
  },
  'paris-4': { 
    name: 'Paris 4√®me', 
    bounds: [[48.8400, 2.3300], [48.8700, 2.3700]], // Zone √©largie
    color: '#ef4444',
    deliveryFee: 3.00,
    estimatedTime: '30-40 min'
  },
  'paris-centre': { 
    name: 'Paris Centre', 
    bounds: [[48.8400, 2.3000], [48.8900, 2.4000]], // Zone centrale large
    color: '#8b5cf6',
    deliveryFee: 2.00,
    estimatedTime: '20-30 min'
  }
};

let map;
let currentMarker;
let zonePolygons = [];
let showZones = false;
let addressSearchTimeout;

// Initialisation de la carte
function initMap() {
  // Position par d√©faut (Paris)
  const defaultPosition = [48.8566, 2.3522];
  
  map = L.map('map').setView(defaultPosition, 13);
  
  // Ajouter les tuiles OpenStreetMap
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    maxZoom: 19
  }).addTo(map);
  
  // Initialiser l'autocompl√©tion
  initAutocomplete();
  
  // Cr√©er les polygones de zones
  createZonePolygons();
  
  // √âcouter les clics sur la carte
  map.on('click', handleMapClick);
  
  // √âcouter les changements de centre de carte
  map.on('moveend', handleMapMoveEnd);
}

// Initialiser l'autocompl√©tion d'adresse avec Nominatim
function initAutocomplete() {
  const addressInput = document.getElementById('address-input');
  const suggestionsDiv = document.getElementById('address-suggestions');
  
  addressInput.addEventListener('input', handleAddressInput);
  
  // Fermer les suggestions en cliquant ailleurs
  document.addEventListener('click', (e) => {
    if (!addressInput.contains(e.target) && !suggestionsDiv.contains(e.target)) {
      suggestionsDiv.style.display = 'none';
    }
  });
}

// G√©rer la saisie d'adresse avec Nominatim
function handleAddressInput() {
  const input = document.getElementById('address-input').value;
  const suggestionsDiv = document.getElementById('address-suggestions');
  
  // Effacer le timeout pr√©c√©dent
  if (addressSearchTimeout) {
    clearTimeout(addressSearchTimeout);
  }
  
  if (input.length < 3) {
    suggestionsDiv.style.display = 'none';
    return;
  }
  
  // D√©lai pour √©viter trop de requ√™tes
  addressSearchTimeout = setTimeout(() => {
    searchAddresses(input);
  }, 300);
}

// Rechercher des adresses avec Nominatim
async function searchAddresses(query) {
  const suggestionsDiv = document.getElementById('address-suggestions');
  
  try {
    const response = await fetch(
      `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=fr&limit=5&addressdetails=1`
    );
    
    const results = await response.json();
    
    if (results.length === 0) {
      suggestionsDiv.style.display = 'none';
      return;
    }
    
    // Afficher les suggestions
    suggestionsDiv.innerHTML = results.map(result => `
      <div class="suggestion-item" data-lat="${result.lat}" data-lng="${result.lon}" data-address="${result.display_name}">
        <div class="suggestion-main">${result.display_name}</div>
        <div class="suggestion-details">${result.type} - ${result.address?.city || result.address?.town || ''}</div>
      </div>
    `).join('');
    
    suggestionsDiv.style.display = 'block';
    
    // Ajouter les √©v√©nements de clic
    suggestionsDiv.querySelectorAll('.suggestion-item').forEach(item => {
      item.addEventListener('click', () => {
        const lat = parseFloat(item.dataset.lat);
        const lng = parseFloat(item.dataset.lng);
        const address = item.dataset.address;
        
        // Centrer la carte sur l'adresse s√©lectionn√©e
        map.setView([lat, lng], 16);
        
        // Placer un marqueur
        placeMarker([lat, lng]);
        
        // Mettre √† jour les champs
        updateAddressFields(address, [lat, lng]);
        
        // Fermer les suggestions
        suggestionsDiv.style.display = 'none';
        document.getElementById('address-input').value = '';
      });
    });
    
  } catch (error) {
    console.error('Erreur lors de la recherche d\'adresse:', error);
    suggestionsDiv.style.display = 'none';
  }
}

// G√©rer les clics sur la carte
function handleMapClick(e) {
  const location = [e.latlng.lat, e.latlng.lng];
  placeMarker(location);
  
  // G√©ocoder l'emplacement cliqu√© avec Nominatim (reverse geocoding)
  reverseGeocode(location);
}

// G√©rer les changements de centre de carte
function handleMapMoveEnd() {
  const center = map.getCenter();
  checkZoneForLocation([center.lat, center.lng]);
}

// G√©ocodage inverse avec Nominatim
async function reverseGeocode(location) {
  try {
    const response = await fetch(
      `https://nominatim.openstreetmap.org/reverse?format=json&lat=${location[0]}&lon=${location[1]}&addressdetails=1`
    );
    
    const result = await response.json();
    
    if (result.display_name) {
      updateAddressFields(result.display_name, location);
    }
  } catch (error) {
    console.error('Erreur lors du g√©ocodage inverse:', error);
  }
}

// Placer un marqueur sur la carte
function placeMarker(location) {
  if (currentMarker) {
    map.removeLayer(currentMarker);
  }
  
  // Cr√©er une ic√¥ne personnalis√©e
  const customIcon = L.divIcon({
    className: 'custom-marker',
    html: '<div class="marker-icon">üìç</div>',
    iconSize: [32, 32],
    iconAnchor: [16, 32]
  });
  
  currentMarker = L.marker(location, { icon: customIcon }).addTo(map);
}

// Cr√©er les polygones de zones de livraison
function createZonePolygons() {
  Object.keys(DELIVERY_ZONES).forEach(zoneId => {
    const zone = DELIVERY_ZONES[zoneId];
    
    // Cr√©er un rectangle pour la zone
    const polygon = L.rectangle(zone.bounds, {
      color: zone.color,
      weight: 2,
      opacity: 0.8,
      fillColor: zone.color,
      fillOpacity: 0.1
    });
    
    if (showZones) {
      polygon.addTo(map);
    }
    
    zonePolygons.push({ polygon, zoneId, zone });
    
    // Ajouter un label pour la zone
    const center = [
      (zone.bounds[0][0] + zone.bounds[1][0]) / 2,
      (zone.bounds[0][1] + zone.bounds[1][1]) / 2
    ];
    
    const label = L.marker(center, {
      icon: L.divIcon({
        className: 'zone-label',
        html: `<div class="zone-label-text">${zone.name}</div>`,
        iconSize: [100, 20],
        iconAnchor: [50, 10]
      })
    });
    
    if (showZones) {
      label.addTo(map);
    }
  });
}

// V√©rifier dans quelle zone se trouve une localisation
function checkZoneForLocation(location) {
  const lat = location[0];
  const lng = location[1];
  
  console.log('V√©rification zone pour:', lat, lng); // Debug
  
  for (const zoneId of Object.keys(DELIVERY_ZONES)) {
    const zone = DELIVERY_ZONES[zoneId];
    const bounds = zone.bounds;
    
    console.log(`Zone ${zoneId}:`, bounds); // Debug
    
    if (lat >= bounds[0][0] && lat <= bounds[1][0] && 
        lng >= bounds[0][1] && lng <= bounds[1][1]) {
      console.log(`Zone trouv√©e: ${zoneId}`); // Debug
      updateZoneInfo(zoneId, zone.name, zone.deliveryFee, zone.estimatedTime);
      return;
    }
  }
  
  console.log('Aucune zone trouv√©e'); // Debug
  updateZoneInfo(null, 'Zone non couverte', null, null);
}

// Mettre √† jour les informations de zone
function updateZoneInfo(zoneId, zoneName, deliveryFee, estimatedTime) {
  const zoneInput = document.getElementById('delivery-zone');
  const zoneInfo = document.getElementById('zone-info');
  const submitButton = document.getElementById('submit-order');
  
  zoneInput.value = zoneId || '';
  
  if (zoneId) {
    zoneInfo.innerHTML = `
      <div class="zone-available">
        ‚úÖ ${zoneName} - Livraison disponible<br>
        <small>Frais: ${deliveryFee}‚Ç¨ | Temps: ${estimatedTime}</small>
      </div>
    `;
    zoneInfo.className = 'zone-info zone-available';
    submitButton.disabled = false;
  } else {
    zoneInfo.innerHTML = `<div class="zone-unavailable">‚ùå ${zoneName} - Livraison non disponible</div>`;
    zoneInfo.className = 'zone-info zone-unavailable';
    submitButton.disabled = true;
  }
}

// Mettre √† jour le champ d'adresse
function updateAddressFields(formattedAddress, location) {
  document.getElementById('address-input').value = formattedAddress;
  checkZoneForLocation(location);
}

// Utiliser la position actuelle
document.getElementById('use-current-location').addEventListener('click', () => {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition((position) => {
      const location = [position.coords.latitude, position.coords.longitude];
      
      map.setView(location, 16);
      placeMarker(location);
      
      // G√©ocoder la position
      reverseGeocode(location);
    }, (error) => {
      alert('Impossible d\'obtenir votre position: ' + error.message);
    });
  } else {
    alert('La g√©olocalisation n\'est pas support√©e par ce navigateur.');
  }
});

// Centrer la carte
document.getElementById('center-map').addEventListener('click', () => {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition((position) => {
      const location = [position.coords.latitude, position.coords.longitude];
      map.setView(location, 16);
    });
  }
});

// Basculer l'affichage des zones
document.getElementById('toggle-zones').addEventListener('click', () => {
  showZones = !showZones;
  
  zonePolygons.forEach(({ polygon, zoneId, zone }) => {
    if (showZones) {
      polygon.addTo(map);
      
      // Ajouter le label
      const center = [
        (zone.bounds[0][0] + zone.bounds[1][0]) / 2,
        (zone.bounds[0][1] + zone.bounds[1][1]) / 2
      ];
      
      const label = L.marker(center, {
        icon: L.divIcon({
          className: 'zone-label',
          html: `<div class="zone-label-text">${zone.name}</div>`,
          iconSize: [100, 20],
          iconAnchor: [50, 10]
        })
      }).addTo(map);
      
      polygon.label = label;
    } else {
      map.removeLayer(polygon);
      if (polygon.label) {
        map.removeLayer(polygon.label);
      }
    }
  });
  
  const button = document.getElementById('toggle-zones');
  button.textContent = showZones ? 'üó∫Ô∏è Masquer les zones' : 'üó∫Ô∏è Afficher les zones';
});

// Tester les zones (bouton de debug)
document.getElementById('test-zones').addEventListener('click', () => {
  const center = map.getCenter();
  const testLocation = [center.lat, center.lng];
  
  console.log('=== TEST DES ZONES ===');
  console.log('Position test√©e:', testLocation);
  console.log('Zones disponibles:', Object.keys(DELIVERY_ZONES));
  
  // Tester chaque zone individuellement
  Object.keys(DELIVERY_ZONES).forEach(zoneId => {
    const zone = DELIVERY_ZONES[zoneId];
    const bounds = zone.bounds;
    const lat = testLocation[0];
    const lng = testLocation[1];
    
    const inZone = lat >= bounds[0][0] && lat <= bounds[1][0] && 
                   lng >= bounds[0][1] && lng <= bounds[1][1];
    
    console.log(`Zone ${zoneId}:`, {
      bounds: bounds,
      inZone: inZone,
      latCheck: `${lat} >= ${bounds[0][0]} && ${lat} <= ${bounds[1][0]} = ${lat >= bounds[0][0] && lat <= bounds[1][0]}`,
      lngCheck: `${lng} >= ${bounds[0][1]} && ${lng} <= ${bounds[1][1]} = ${lng >= bounds[0][1] && lng <= bounds[1][1]}`
    });
  });
  
  // Appeler la fonction de v√©rification
  checkZoneForLocation(testLocation);
  
  alert('Test des zones effectu√© ! Consultez la console (F12) pour voir les d√©tails.');
});

// Effacer l'adresse
document.getElementById('clear-address').addEventListener('click', () => {
  document.getElementById('address-input').value = '';
  document.getElementById('delivery-zone').value = '';
  document.getElementById('zone-info').innerHTML = '';
  document.getElementById('zone-info').className = 'zone-info';
  document.getElementById('submit-order').disabled = true;
  
  // Supprimer le marqueur de la carte
  if (currentMarker) {
    map.removeLayer(currentMarker);
    currentMarker = null;
  }
});

// Soumettre le formulaire
document.getElementById('checkout-form').addEventListener('submit', (e) => {
  const address = document.getElementById('address-input').value;
  const zone = document.getElementById('delivery-zone').value;
  
  if (!address || !zone) {
    e.preventDefault();
    alert('Veuillez remplir l\'adresse et s√©lectionner une zone de livraison.');
    return;
  }
  
  // Mettre √† jour les champs cach√©s
  document.getElementById('final-address').value = address;
  document.getElementById('final-zone').value = zone;
});

// Gestion du panier
function initCartControls() {
  // Boutons de quantit√©
  document.querySelectorAll('.btn-quantity').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const itemName = e.target.dataset.item;
      const action = e.target.dataset.action;
      const quantityInput = document.querySelector(`input[data-item="${itemName}"]`);
      let currentQty = parseInt(quantityInput.value);
      
      if (action === 'increase' && currentQty < 10) {
        quantityInput.value = currentQty + 1;
      } else if (action === 'decrease' && currentQty > 0) {
        quantityInput.value = currentQty - 1;
      }
      
      updateItemTotal(itemName);
      updateCartTotal();
    });
  });
  
  // Inputs de quantit√©
  document.querySelectorAll('.quantity-input').forEach(input => {
    input.addEventListener('change', (e) => {
      const itemName = e.target.dataset.item;
      let qty = parseInt(e.target.value);
      
      if (qty < 0) qty = 0;
      if (qty > 10) qty = 10;
      
      e.target.value = qty;
      updateItemTotal(itemName);
      updateCartTotal();
    });
  });
  
  // Boutons de suppression
  document.querySelectorAll('.btn-remove').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const itemName = e.target.dataset.item;
      if (confirm(`Supprimer "${itemName}" du panier ?`)) {
        removeItemFromCart(itemName);
      }
    });
  });
  
  // Bouton vider le panier
  document.getElementById('clear-cart').addEventListener('click', () => {
    if (confirm('Vider compl√®tement le panier ?')) {
      clearCart();
    }
  });
  
  // Bouton mettre √† jour
  document.getElementById('update-cart').addEventListener('click', () => {
    updateCart();
  });
}

// Mettre √† jour le total d'un article
function updateItemTotal(itemName) {
  const quantityInput = document.querySelector(`input[data-item="${itemName}"]`);
  const price = parseFloat(quantityInput.dataset.price);
  const quantity = parseInt(quantityInput.value);
  const totalPrice = price * quantity;
  
  const totalElement = document.querySelector(`[data-item="${itemName}"] .item-total-price`);
  totalElement.textContent = `${totalPrice.toFixed(2)} ‚Ç¨`;
  
  // Masquer l'article si quantit√© = 0
  const cartItem = document.querySelector(`[data-item="${itemName}"]`);
  if (quantity === 0) {
    cartItem.style.opacity = '0.5';
    cartItem.style.textDecoration = 'line-through';
  } else {
    cartItem.style.opacity = '1';
    cartItem.style.textDecoration = 'none';
  }
}

// Mettre √† jour le total du panier
function updateCartTotal() {
  let total = 0;
  document.querySelectorAll('.quantity-input').forEach(input => {
    const quantity = parseInt(input.value);
    const price = parseFloat(input.dataset.price);
    total += quantity * price;
  });
  
  document.querySelector('.total-price').textContent = `${total.toFixed(2)} ‚Ç¨`;
}

// Supprimer un article du panier
function removeItemFromCart(itemName) {
  // Cr√©er un formulaire pour supprimer l'article
  const form = document.createElement('form');
  form.method = 'POST';
  form.action = '{{ url_for("client_remove_line") }}';
  
  // Ajouter le nom de l'article
  const itemInput = document.createElement('input');
  itemInput.type = 'hidden';
  itemInput.name = 'item_name';
  itemInput.value = itemName;
  form.appendChild(itemInput);
  
  // Ajouter le token CSRF si n√©cessaire
  const csrfToken = document.querySelector('input[name="csrf_token"]');
  if (csrfToken) {
    form.appendChild(csrfToken.cloneNode());
  }
  
  // Soumettre le formulaire
  document.body.appendChild(form);
  form.submit();
}

// Vider le panier
function clearCart() {
  // Cr√©er un formulaire pour vider le panier
  const form = document.createElement('form');
  form.method = 'POST';
  form.action = '{{ url_for("client_cart") }}';
  
  // Ajouter un champ cach√© pour indiquer l'action
  const actionInput = document.createElement('input');
  actionInput.type = 'hidden';
  actionInput.name = 'action';
  actionInput.value = 'clear';
  form.appendChild(actionInput);
  
  // Ajouter le token CSRF si n√©cessaire
  const csrfToken = document.querySelector('input[name="csrf_token"]');
  if (csrfToken) {
    form.appendChild(csrfToken.cloneNode());
  }
  
  // Soumettre le formulaire
  document.body.appendChild(form);
  form.submit();
}

// Mettre √† jour le panier
function updateCart() {
  const cartData = [];
  
  document.querySelectorAll('.cart-item').forEach(item => {
    const itemName = item.dataset.item;
    const quantityInput = document.querySelector(`input[data-item="${itemName}"]`);
    const quantity = parseInt(quantityInput.value);
    
    if (quantity > 0) {
      cartData.push({
        nom: itemName,
        qty: quantity,
        pu: parseFloat(quantityInput.dataset.price)
      });
    }
  });
  
  // Cr√©er un formulaire pour mettre √† jour le panier
  const form = document.createElement('form');
  form.method = 'POST';
  form.action = '{{ url_for("client_cart") }}';
  
  // Ajouter un champ cach√© pour indiquer l'action
  const actionInput = document.createElement('input');
  actionInput.type = 'hidden';
  actionInput.name = 'action';
  actionInput.value = 'update';
  form.appendChild(actionInput);
  
  // Ajouter les donn√©es du panier
  const cartInput = document.createElement('input');
  cartInput.type = 'hidden';
  cartInput.name = 'cart_data';
  cartInput.value = JSON.stringify(cartData);
  form.appendChild(cartInput);
  
  // Ajouter le token CSRF si n√©cessaire
  const csrfToken = document.querySelector('input[name="csrf_token"]');
  if (csrfToken) {
    form.appendChild(csrfToken.cloneNode());
  }
  
  // Soumettre le formulaire
  document.body.appendChild(form);
  form.submit();
}

// Initialiser la carte quand la page est charg√©e
document.addEventListener('DOMContentLoaded', () => {
  initMap();
  initCartControls();
});
</script>
{% endblock %}
